<html><head><meta http-equiv="content-type" content="text/html; charset=UTF-8"><title>Google Search:</title><style><!--
body,td,div,.p,a{font-family:arial,sans-serif }
div,td{color:#000}
.f,.fl:link{color:#6f6f6f}
a:link,.w,a.w:link,.w a:link{color:#00c}
a:visited,.fl:visited{color:#551a8b}
a:active,.fl:active{color:#f00}
.t a:link,.t a:active,.t a:visited,.t{color:#000000}
.t{background-color:#ffcc33}
.h{color:#ddaa11}
.i,.i:link{color:#a90a08}
.a,.a:link{color:#008000}
.z{display:none}
div.n {margin-top: 1ex}
.n a{font-size:10pt; color:#000}
.n .i{font-size:10pt; font-weight:bold}
.q a:visited,.q a:link,.q a:active,.q {text-decoration: none; color: #00c;}
.b{font-size: 12pt; color:#00c; font-weight:bold}
.ch{cursor:pointer;cursor:hand}
//-->
</style>
<script>
<!--
function ss(w){window.status=w;return true;}
function cs(){window.status='';}
//-->
</script>
<script>
<!--
function ga(o,e){if (document.getElementById){a=o.id.substring(1); p = "";r = "";g = e.target;if (g) { t = g.id;f = g.parentNode;if (f) {p = f.id;h = f.parentNode;if (h) r = h.id;}} else{h = e.srcElement;f = h.parentNode;if (f) p = f.id;t = h.id;}if (t==a || p==a || r==a) return true;location.href=document.getElementById(a).href}}
//-->
</script></head><body bgcolor="#ffffff" onload="document.gs.reset()"><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td rowspan="3" valign="top"><table cellpadding="0" cellspacing="0" border="0"><tbody><tr><td align="right" valign="bottom"><a href="http://groups.google.com/grphp?hl=en"><img src="groups_files/res0.gif" alt="Go to Google Groups Home" border="0" width="110" height="58"></a></td><td valign="bottom"><a href="http://groups.google.com/grphp?hl=en"><img src="groups_files/res1.gif" border="0" width="38" height="58" alt=""></a></td><td valign="bottom"><a href="http://groups.google.com/grphp?hl=en"><img src="groups_files/res2.gif" border="0" width="52" height="58" alt=""></a></td></tr><tr><td align="right" valign="top" class="h"><b>Groups</b></td><td valign="top"><a href="http://groups.google.com/grphp?hl=en"><img src="groups_files/res3.gif" border="0" width="38" height="20" alt=""></a></td><td valign="top"><font color="#6f6f6f" size="-1"> </font></td></tr></tbody></table></td><td nowrap="nowrap"><font size="-1"><a href="http://groups.google.com/advanced_group_search?hl=en&amp;lr=&amp;ie=UTF-8&amp;oe=UTF-8">Advanced Groups Search</a>    <a href="http://groups.google.com/preferences?hl=en&amp;lr=&amp;ie=UTF-8&amp;oe=UTF-8">Preferences</a>    <a href="http://groups.google.com/googlegroups/help.html">Groups Help</a> </font></td></tr><tr><td valign="middle"><form name="gs" method="get" action="/groups"><input type="hidden" name="hl" value="en"><input type="hidden" name="lr" value=""><input type="hidden" name="ie" value="UTF-8"><input type="hidden" name="oe" value="UTF-8"><input type="text" name="q" size="31" maxlength="2048" value=""><font size="-1"> <input type="submit" name="btnG" value="Google Search"><span id="hf"></span></font></form></td></tr><tr><td><font size="-1"> </font></td></tr></tbody></table><table width="100%" border="0" cellpadding="1" cellspacing="0" bgcolor="#ffcc33"><tbody><tr><td bgcolor="#ffcc33" nowrap="nowrap"><table width="100%" border="0" cellpadding="1" cellspacing="0" bgcolor="#ffcc33"><tbody><tr><td bgcolor="#ffcc33" nowrap="nowrap"><font size="-1" color="#000000"><b>Groups search result 7</b> for <b></b>  </font></td></tr></tbody></table></td></tr></tbody></table><table cellspacing="0" cellpadding="0" width="100%" border="0"><tbody><tr><td height="5"><img alt="" width="1" height="1"></td></tr></tbody></table><table cellspacing="0" cellpadding="2" width="100%" border="0" bgcolor="#ebffed"><tbody><tr><td class="ch" id="taw0" onmouseover="ss('go to www.synthesysresearch.com')" onclick="ga(this,event)" onmouseout="cs()"><font size="-1"> <a id="aw0" href="http://groups.google.com/url?q=http://www.synthesysresearch.com/ba1500.htm&amp;sa=l&amp;ai=Av_k4csPv-svy6Qq5gIaMICKXqCrkCAcj3GgABAuT6PBo-rQADEAwVA&amp;num=1&amp;client=ca-groups-message"><b>Measure DJ and RJ Jitter</b></a> • <font class="f" size="-2">The most efficient method uses BER BitAlyzer has Jitter Built-In</font> • <font color="green" size="-1">www.synthesysresearch.com</font></font></td><td rowspan="3" valign="top" align="right"><font size="-2" color="#6f6f6f">Sponsored Links</font> <br></td></tr><tr><td class="ch" id="taw1" onmouseover="ss('go to www.dspos.com')" onclick="ga(this,event)" onmouseout="cs()"><font size="-1"> <a id="aw1" href="http://groups.google.com/url?q=http://www.dspos.com/DSPOSWeb/InternetProtocol/fusion_ttcp.htm&amp;sa=l&amp;ai=AWFRccsPv-svy6Qq5gIaM9TJzBEKgzTAwNebACIA4Op_EgT9ABMgAAXB&amp;num=2&amp;client=ca-groups-message"><b>Fusion T/TCP</b></a> • <font class="f" size="-2">Any RTOS or processor. Transaction TCP. No royalties!</font> • <font color="green" size="-1">www.dspos.com</font></font></td></tr><tr><td class="ch" id="taw2" onmouseover="ss('go to download.sniff-em.com')" onclick="ga(this,event)" onmouseout="cs()"><font size="-1"> <a id="aw2" href="http://groups.google.com/url?q=http://www.sniff-em.com&amp;sa=l&amp;ai=AGqMkcsPv-svy6Qq5gIaMuH9K4mpuBAcj3GgADAuT6PB0GOQADMAwVA&amp;num=3&amp;client=ca-groups-message"><b>Sniff'em Packet Sniffer</b></a> • <font class="f" size="-2">Next-Generation Windows based Packet Sniffer, Trial available</font> • <font color="green" size="-1">download.sniff-em.com</font></font></td></tr></tbody></table><table cellspacing="0" cellpadding="0" width="100%" border="0"><tbody><tr><td height="5"><img alt="" width="1" height="1"></td></tr></tbody></table>
<table width="100%" bgcolor="#e0e0e0" cellpadding="2" cellspacing="0" border="0"><tbody><tr><td><font face="arial,sans-serif">

<table cellpadding="0" cellspacing="0" border="0" align="right"><tbody><tr><td><font face="arial,sans-serif"></font></td></tr></tbody></table>
From: <a href="http://groups.google.com/groups?hl=en&amp;lr=&amp;ie=UTF-8&amp;oe=UTF-8&amp;q=author:foo%40bar.baz.invalid+">Rick Jones</a> (<a href="mailto:foo%40bar.baz.invalid">foo@bar.baz.invalid</a>)<br>Subject: Re: Looking for algorithms to limit TCP send() and recv() <br><font face="arial,sans-serif"><table cellpadding="0" cellspacing="0" border="0" align="right"><tbody><tr><td>View: <a href="http://groups.google.com/groups?hl=en&amp;lr=&amp;ie=UTF-8&amp;oe=UTF-8&amp;threadm=asr31j%244eh%245%40web1.cup.hp.com&amp;rnum=7&amp;prev=/groups%3Fhl%3Den%26lr%3D%26ie%3DUTF-8%26oe%3DUTF-8%26selm%3Dasr31j%25244eh%25245%2540web1.cup.hp.com%26rnum%3D7">Complete Thread (10 articles)</a> </td></tr><tr><td align="right"> <a href="http://groups.google.com/groups?selm=asr31j%244eh%245%40web1.cup.hp.com&amp;oe=UTF-8&amp;output=gplain">Original Format</a></td></tr></tbody></table></font>
Newsgroups: <a href="http://groups.google.com/groups?hl=en&amp;lr=&amp;ie=UTF-8&amp;oe=UTF-8&amp;group=comp.protocols.tcp-ip">comp.protocols.tcp-ip</a><br>Date: 2002-12-06 13:21:49 PST <br></font></td></tr></tbody></table><pre>Ed Fair &lt;ed_fair@yahoo.com&gt; wrote:

<font color="#660066">&gt; I think I see what you're saying, let me repeat it back:  Although my
&gt; application might delay recving() data,
&gt; 1) The TCP SYN packets (which are sent/received by the kernel, not the
&gt; application) will continue to flow as normal, and
&gt; 2) My delays may even generate additional SYN packets, and
&gt; 3) The TCP window size will probably not shrink as a result of my delays,
&gt; and
&gt; 4) I may expose myself to a corner case that may not be handled well in some
&gt; IP stacks.</font>

Ah... no :) What I was discussing did not involve SYN segments. Those
are strictly connection establishment segments, and there are no SYN
segments sent when one is at the stage of calling recv() or send().

TCP is a flow-controlled protocol. Flow-control is implemented with a
sliding window advertised by the receiver.

When data arrives at a receiver, TCP will place that data into the
application's socket buffer.

When a receiver advertises a given window value, he is making a pledge
to the sender that the receiver can hold at least that much data.  The
size of the applcation's socket buffer determines the maximum value of
that pledge.

When the application "consumes" data from the socket buffer (ie calls
recv()), the TCP stack is then able to "update" or "slide" the window
to tell the sender that he can send more data.

A receiving TCP must also ACKnowledge receipt of data - this is so the
sender knows it arrived at the receiving TCP and does not need to be
retransmitted.

ACKs and Window Updates are logically distinct things.

A simple TCP could send an immediate ACK upon receipt of data.
However, sending or receiving an ACK segment is, more or less, just as
expensive (in terms of CPU cycles) as sending a data packet.

Similarly, sending/receiving a window update would be just as
expensive as sending an ACK.

So, TCP has some heuristics to avoid sending ACKs and window updates
by themselves, but still provide timely feedback to the sender. 

In broad terms, the ACK policy goes something like this:

1) if there is data to be sent the other way, piggyback the ACK.
2) if there is a window update to be sent the other way, piggyback the ACK
3) if the standalone ACK timer expires, send the ACK.

If there is no data to be sent the other way, that leaves heuristics
two and three. 

Window updates are only generated when applications consume data from
the socket buffer. If the application is pacing its recv() calls, this
means that it may be a long time before a window update is
apropriate. 

This leaves just heursitic three.

So, if you pace-out recv() calls, it may delay window updates, which
will force the receiving TCP to send standalone ACKs - if the
receiving TCP didn't have that standalone ACK timer, the sending TCP,
which is running a retransmission timer, may send an otherwise
unnecessary retransmission of the data, wasting bandwidth and CPU
cycles.

Now, switch back to the sender - if the recieving app is pacing the
recv() calls, and the sender has a large quantity of data to send and
not sending at the receiver's slower pace, eventually the TCP window
is going to be filled.  However, the standalone ACK timers on the
reciever will expire, so the sending TCP will receive the ACKs.

Since a sending TCP receives the ACKs, it no longer runs its
retransmission timer.  Now, at this point, it is possible that the
remote (recieving) system could dissapear off the face of the
network. If that happens, the sending TCP could be stuck there
forever. It has no timers running, it will receive no packets from the
remote TCP, and the local application may not continue calling send()
or whatnot.

This could be bad.

So, the sending TCP will start "probing" the remote TCP - in part to
make sure it is still there, and in part to help the receiving TCP to
"remember" that it needs to send a window update (particularly if the
receiving TCP only looks at the state of the socket buffer when
traffic arrives from the network and does not get told directly by the
socket code when data is consumed).

So, that is why pacing data flow by spacing recv() calls can (but may
not always) triger behaviours in TCP that would not be seen if the
traffic were flowing over a "real" link of that speed.  Whether or not
this is an issue depends on circumstance. It was an issue for a web
server benchmark, it may or may not be an issue for your application.


BTW, the suggestion to use smaller window sizes is indeed another way
to limit the flow rate - so long as the expression W/RTT is less than
or equal to the desired flow rate. W is the window size, RTT is the
round-trip-time.  Going back to TCP being flow controlled, a sending
TCP can only send one window's worth of data out onto the network
before he must stop and await a window update from the remote. The
fastest a window update could arrive from the remote is one RTT, hence
a TCP connection can send data no faster than W/RTT.

Now, while you have control over W by setting the socket buffer size,
you do not have control over RTT, and different remote systems may
have different RTTs, so you would have/want to have different values
of W to give different clients the same throughput.

In general, it is considered a no-no to shrink the socket buffer after
the connection has been established. Particularly in the past, TCPs
did not deal with that situation very well.

Connections should be considered established after a call to
connect(), or listen() - yes listen and not accept() - accept() give
the app an already established connection, connections can start to be
established after listen() is called.

It is however, considered OK to increase the size of the socket buffer
after a connection is established.

Of course, there are considerations there as well :) First is that
there are really _three_ windows at work in TCP. It might be more
accurate to say that three things contribute to the "effective" window
of a TCP connection.

We've already considered the classic TCP window - the field in the TCP
header that is based on the recieve socket buffer size. SO_RCVBUF.

Similarly, the send socket buffer size on the sender controls how much
data can be inflight at one time. A sending TCP must retain a
reference to the data until an ACK arrives. It does this (generally)
by copying the data in the send() call into the send socket buffer. It
cannot put more data than SO_SNDBUF into the send socket buffer, so it
cannot have more than SO_SNDBUF bytes of data outstanding on the
network. If the sender's SO_SNDBUF is &lt; the receiver's SO_RCVBUF, the
'effective' W in that W/RTT calculation becomes SO_SNDBUF.

So, if your receiver increases SO_RCVBUF, it will only "do good" if
the sender's SO_SNDBUF is &gt;= the reciever's SO_RCVBUF.

Now, the third component is somewhat beyond your control. That is the
"congestion window."  The congestion window is something tracked more
or elss only by the sending TCP. A sending TCP counts how many
segments it can have outstanding on the network before triggering a
packet loss. When TCP detects packet loss, it shrinks its congestion
window.

So, the effective window at any point in time will be the minimum of
the receiver's SO_RCVBUF, the sender's SO_SNDBUF, and the sending
TCP's calculated congestion window - often called the "cwdn."

And if that wasn't enough, there is another consideration with window
sizes!-)

The window size field of TCP is only 16 bits in size. This means that
a classic TCP window cannot be any larger than 2^16-1 or 65535
bytes. For many situations this is such that W/RTT would be less than
link rate. Not good.

So an extension to TCP was devised. The extension is called "window scaling."

Window scaling works by saying that the value in the classic 16 bit
window field should be "scaled" by multiplying it by a specified power
of two. This scaling factor is exchanged as a TCP option that is
exchanged only (iirc) during connection establishement - ie when the
SYNs are exchanged.

A TCP will base its scaling factor on the size of the SO_RCVBUF when
it sends its SYN segment. That is to say, it will base the scaling
factor on the size of SO_RCVBUF when the application calls connect()
or listen(). If the size of SO_SNDBUF is &lt; 65536 bytes at that time,
no scaling factor is exchanged. If then the SO_SNDBUF is increased to
a value &gt; 65535 bytes, it will have no effect on the effective window
size.

And if you have a large SO_RCVBUF before calling connect() or
listen(), you get back to it being considered a no-no to shrink the
window after a connection is established :)

Welcome to TCP. You are in a maze of twisty heuristics, all different.

rick jones
<font color="#007777">-- 
oxymoron n, commuter in a gas-guzzling luxury SUV with an American flag
these opinions are mine, all mine; HP might not want them anyway... :)
feel free to post, OR email to raj in cup.hp.com  but NOT BOTH...</font></pre><center><p></p><hr class="z"><table width="100%" cellpadding="2" cellspacing="0" border="0"><tbody><tr><td class="t" align="center"><font size="-1"><a href="http://www.google.com/">Google Home</a> - <a href="http://groups.google.com/ads/">Advertise with Us</a> - <a href="http://groups.google.com/services/">Business Solutions</a> - <a href="http://groups.google.com/options/">Services &amp; Tools</a> - <a href="http://groups.google.com/about.html">Jobs, Press, &amp; Help</a></font></td></tr></tbody></table><br><font size="-1" class="p">©2003 Google</font></center></body></html>